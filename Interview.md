# 面试
## 1.内联函数，优点及缺点

内联函数是一种在编译时将函数体直接插入到每个调用位置的函数。这样可以减少函数调用的开销，因为不需要跳转到函数，保存寄存器，然后再跳回来。但是，如果函数体很大，这可能会导致代码膨胀，因为函数体的每个副本都需要空间。

优点：

1.  内联函数可以提高程序的运行速度，因为它们消除了函数调用的开销。
2.  内联函数在编译时展开，因此编译器有更多的优化机会，例如常量折叠。

缺点：

1.  内联函数可能会导致代码膨胀。如果函数体很大，或者内联函数在代码中被频繁调用，那么编译后的代码可能会变得非常大。

2.  内联函数可能会导致编译时间增加，因为编译器需要处理更多的代码。

3.  如果修改了内联函数的定义，那么所有使用该函数的代码都需要重新编译。

    

## 3.容器：map，set

在C++中，`map`和`set`都是基于红黑树（一种自平衡二叉查找树）实现的

`unordered_map`和`unordered_set`的内部实现是哈希表，因此它们的查找、插入和删除操作的平均时间复杂度是O(1)。然而，由于哈希表的特性，它们不保证元素的顺序。

在拉链法中，每个哈希表的元素都是一个链表。当新的数据项映射到已经有数据项的地址时，新的数据项就被添加到该地址的链表中。



## 4. 浏览器输入网址，直到打开网页的过程

浏览器输入网址到打开网页的过程包括以下步骤：

1.  **DNS 解析**：浏览器首先会进行 DNS 解析，将你输入的网址（例如 [www.example.com](http://www.example.com/)）转换为服务器的 IP 地址。
2.  **建立 TCP 连接**：浏览器与服务器建立 TCP 连接，这通常涉及到一个“三次握手”的过程。
3.  **发送 HTTP 请求**：浏览器向服务器发送 HTTP 请求，请求包括你想要获取的资源（例如一个网页）。
4.  **服务器处理请求并返回 HTTP 响应**：服务器处理你的请求，然后返回一个 HTTP 响应，响应中包含你请求的资源，例如一个 HTML 文件。
5.  **浏览器渲染页面**：浏览器接收到服务器返回的 HTML 文件后，开始解析 HTML，CSS 和 JavaScript，然后渲染出页面。
6.  **关闭 TCP 连接**：如果 HTTP 响应头中的 `Connection` 字段的值为 `close`，或者 HTTP 1.0 协议默认不支持长连接，那么浏览器和服务器的 TCP 连接会在数据交换完毕后关闭。



## 8.tcp头有哪些字段

TCP（Transmission Control Protocol，传输控制协议）头部包含以下字段：

1.  **源端口**（Source Port）：16位，用于标识发送端的应用程序。
2.  **目标端口**（Destination Port）：16位，用于标识接收端的应用程序。
3.  **序列号**（Sequence Number）：32位，用于标识从TCP源端向目标端发送的字节流，它表示在这个报文段中的的第一个数据字节。
4.  **确认号**（Acknowledgement Number）：32位，只有ACK标志位为1时，确认号字段才有效。ACK=1，确认号值为期望收到对方下一个报文段的第一个数据字节的序列号。
5.  **数据偏移**（Data Offset）：4位，指示TCP报文段的数据起始处距TCP报文段的起始处有多远。
6.  **保留**（Reserved）：6位，为后续使用而保留，目前值为0。
7.  **控制位**（Control Bits）：包括URG、ACK、PSH、RST、SYN、FIN等6个标志位。
8.  **窗口大小**（Window Size）：16位，用于流量控制。
9.  **校验和**（Checksum）：16位，用于错误检测。
10.  **紧急指针**（Urgent Pointer）：16位，只有URG标志位为1时，紧急指针字段才有效。
11.  **选项**（Options）：长度可变，最多可有40字节。不是所有的TCP报文段都有该字段。





## 公网ip怎么映射成私网ip

通过NAT转换



## 网络号怎么计算

网络号(Network ID)是一个用于识别特定网络的唯一标识符。在IP地址中，网络号是IP地址的一部分，它标识了网络的位置。网络号和主机号一起构成了一个完整的IP地址。

IP地址 192.168.1.1和 一个子网掩码255.255.255.0，它们取AND，因此网络号是192.168.1.0



## 进程间通信

进程间通信（Inter-Process Communication，IPC）是指在不同进程之间传递数据或信号的一种机制。在操作系统中，有多种方法可以实现进程间通信，包括管道（Pipe）、消息队列（Message Queuing）、信号（Signal）、共享内存（Shared Memory）、套接字（Socket）等。

以下是一些基本的IPC方法：

1.  **管道（Pipe）**：管道是一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

```
#include <unistd.h>
int pipe(int pipefd[2]);
```

1.  **消息队列（Message Queuing）**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冡区大小受限等缺点。

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
msgget(key_t key, int msgflg);
```

1.  **信号（Signal）**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

```
#include <signal.h>
void (*signal(int signum, void (*handler)(int)))(int);
```

1.  **共享内存（Shared Memory）**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

```
#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

1.  **套接字（Socket）**：套接字是一种全双工的通信方式，可用于不同机器之间的进程通信。

```
#include <sys/types.h>
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

以上就是进程间通信的基本方法，每种方法都有其适用的场景和优缺点，需要根据实际需求来选择。







## 简述一下 GDB 常见的调试命令

GDB（GNU调试器）是一个强大的Unix下的源代码级调试器。下面是一些常见的GDB命令：

- `run` (`r`): 开始程序的执行。如果程序需要命令行参数，你可以在`run`后面添加这些参数。

- `break` (`b`): 设置断点。你可以使用函数名、源文件名和行号等来设置断点。如 `break main` 或 `break myfile.c:20`。

- `continue` (`c`): 继续运行程序，直到下一个断点或者程序结束。

- `next` (`n`): 执行下一行代码。如果当前行有函数调用，`next`会跳过整个函数。

- `step` (`s`): 执行下一行代码。如果当前行有函数调用，`step`会进入函数。

- `print` (`p`): 打印表达式的值。例如，`print foo`会打印变量`foo`的值。

- `list` (`l`): 显示源代码。你可以使用`list`命令无参数地查看当前执行的代码周围的源代码，或者指定一个函数名或者行号来查看特定的源代码。

- `quit` (`q`): 退出GDB。

- `backtrace` (`bt`): 显示函数调用栈。这在你需要知道函数调用的顺序或者当前在哪个函数中时非常有用。

- `info` (`i`): 显示各种信息。例如，`info locals`会显示当前栈帧的局部变量，`info breakpoints`会显示所有的断点。

- `set var`: 修改变量的值。例如，`set var foo=5`会设置变量`foo`的值为5。

- `watch`: 设置一个观察点，当指定的表达式的值改变时，程序会暂停执行。

每个命令都有更详细的选项和用法，你可以在GDB中使用`help`命令来查看更多的信息。





## 静态库和动态库如何制作及使用，区别是什么

静态库和动态库是两种不同的软件库类型，它们都用来存储编译后的代码，但其使用方式和制作步骤存在一些差异。

#### 制作静态库

假设你有一些`.c`源文件，你可以通过以下步骤创建静态库：

1. 编译源文件为目标文件。例如，对于源文件`a.c`和`b.c`，你可以在命令行中使用以下命令：

    ```
    gcc -c a.c b.c
    ```

    这会生成`a.o`和`b.o`目标文件。

2. 使用`ar`命令创建静态库。例如，创建一个名为`libfoo.a`的库，可以使用以下命令：

    ```
    ar rcs libfoo.a a.o b.o
    ```

#### 制作动态库

制作动态库的步骤与制作静态库类似，但是需要使用不同的标志。例如，对于同样的`a.c`和`b.c`源文件，你可以使用以下命令：

1. 编译源文件为目标文件，但要使用`-fPIC`标志，这是为了生成位置无关代码：

    ```
    gcc -c -fPIC a.c b.c
    ```

2. 使用`-shared`标志创建动态库。例如，创建一个名为`libfoo.so`的库，可以使用以下命令：

    ```
    gcc -shared -o libfoo.so a.o b.o
    ```

#### 使用静态库和动态库

在你的程序中使用这些库，你需要在链接时指定它们。例如，如果你的程序源文件是`main.c`，你可以使用以下命令链接静态库：

```
gcc main.c -L. -lfoo -o main
```

同样，你可以使用以下命令链接动态库：

```
gcc main.c -L. -lfoo -o main
```

在这里，`-L.`告诉链接器在当前目录中搜索库，`-lfoo`告诉链接器链接名为`libfoo`的库（无论是`.a`还是`.so`）。

#### 静态库和动态库的区别

静态库在编译时被包含在最终的可执行文件中，这意味着如果程序使用了静态库，那么这个库的所有代码都会被复制到最终的可执行文件中。这会使得可执行文件变大，但在运行程序时不需要额外的依赖。

相比之下，动态库在运行时被加载。这意味着可执行文件只包含一些引用到动态库的代码的标识，而不是库的实际代码。这可以使得可执行文件更小，但在运行时需要确保动态库可用。

此外，动态库还有一些其他的优点，例如可以被多个程序共享，可以被热更新等。但是，动态库也带来了一些复杂性，例如需要正确配置库的搜索路径，处理版本兼容性等。





## 说一说进程调度算法有哪些

进程调度算法是操作系统用于决定哪个进程应该获得处理器资源的方法。以下是一些常见的进程调度算法：

- **先来先服务 (First-Come, First-Served, FCFS)**: 这是最简单的调度算法。在这种模式下，操作系统按照进程到达的顺序进行调度。FCFS算法可能导致"饥饿"，也就是某些进程可能需要等待很长时间才能得到执行。

- **最短作业优先 (Shortest Job Next, SJN)**: SJN算法选择最短执行时间的进程进行调度。这种算法可以最小化平均等待时间，但是也可能导致长作业饥饿。

- **优先级调度 (Priority Scheduling)**: 在这种算法下，每个进程都有一个优先级，优先级高的进程被优先调度。优先级调度可能会引起低优先级进程饥饿，这可以通过引入优先级老化（即，等待时间越长的进程，其优先级逐渐提高）来解决。

- **轮转法 (Round Robin, RR)**: RR算法中，每个进程都被分配到一小段连续的执行时间，称为时间片。当一个进程的时间片用完，就把CPU分配给下一个进程。这种方法避免了饥饿问题，但是如果时间片选择不当，可能会导致过多的上下文切换，降低系统性能。

- **多级反馈队列 (Multi-Level Feedback Queue, MLFQ)**: MLFQ结合了优先级调度和RR的特点。它将进程分成多个队列，每个队列有不同的优先级。在同一队列中，进程通过RR进行调度。当一个进程用完其分配的时间片，它会被移动到优先级更低的队列。这个算法试图给予短作业和I/O密集型进程更多的处理器时间。

以上都是理想化的调度算法，实际的操作系统会使用更复杂的调度策略，可能会结合上述多种算法的特点。





## 说一说什么是大端、小端，如何判断大端和小端

**大端 (Big Endian)** 和 **小端 (Little Endian)** 是计算机科学中的术语，用于描述字节序或者端序，即数据在内存中如何存储和读取。

- **大端 (Big Endian)**: 高位字节存储在内存的低地址中，低位字节存储在内存的高地址中。例如，一个32位的整数0x12345678，在大端模式下存储为：

    ```
    低地址 -> | 12 | 34 | 56 | 78 | <- 高地址
    ```

- **小端 (Little Endian)**: 低位字节存储在内存的低地址中，高位字节存储在内存的高地址中。同样的整数0x12345678，在小端模式下存储为：

    ```
    低地址 -> | 78 | 56 | 34 | 12 | <- 高地址
    ```

**判断大端和小端的方法**：

一种常见的判断系统是大端还是小端的方法是通过一个叫做"联合体 (union)"的数据结构。联合体可以让你在同一段内存上以多种方式进行读写。以下是一个使用C语言的示例：

```c
#include <stdio.h>

union {
    int i;
    char c[sizeof(int)];
} x;

int main() {
    x.i = 1;
    if (x.c[0] == 1) {
        printf("Little Endian\n");
    } else {
        printf("Big Endian\n");
    }
    return 0;
}
```

在这个代码中，我们创建了一个整数和一个字符数组共享存储空间的联合体。然后，我们给整数赋值为1，然后检查字符数组的第一个字节。如果第一个字节为1，那么系统为小端模式。如果不是，那么系统为大端模式。



## 请你说说进程和线程的区别

**进程（Process）** 和 **线程（Thread）** 都是操作系统的基本概念，它们是操作系统进行资源分配和调度的基本单位，但是它们之间有一些重要的区别。

- **进程：** 进程是操作系统进行资源分配的基本单位，它包含了运行程序所需要的资源，如CPU时间、内存空间、文件、设备等。每个进程都有自己的独立地址空间，一个进程无法直接访问另一个进程的资源。

- **线程：** 线程是操作系统进行调度的基本单位，它是在进程内部的一个独立执行路径。一个进程可以包含多个线程，这些线程共享进程的地址空间和其它资源，可以并发执行。

以下是进程和线程的主要区别：

1. **资源开销：** 创建或者终止一个进程的开销通常要大于创建或者终止一个线程。同样，由于进程间的切换需要交换更多的信息，所以进程切换的开销也比线程切换大。

2. **通信：** 由于同一进程下的线程共享内存和其它资源，所以线程间的通信比较容易。而进程间的通信（IPC，Inter-Process Communication）需要使用特定的操作系统API，相比较而言比较复杂。

3. **安全：** 由于进程有独立的地址空间，所以一个进程崩溃不会影响其他进程，这对于系统的稳定性和安全性是有利的。而多线程程序中，一个错误的线程可能影响整个进程的稳定性。

总的来说，进程和线程都是多任务处理的手段，它们各有优缺点。在编程时，应根据应用的需求和特性选择使用进程还是线程。





## 请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁

死锁是指在并发系统中，两个或多个进程互相等待对方所持有的资源，而导致所有进程处于无法继续执行的状态。

死锁产生的必要条件包括：

1. 互斥条件：资源只能被一个进程占有或使用。
2. 请求与保持条件：一个进程在请求资源的同时已经占有了至少一个资源。
3. 资源不可剥夺条件：资源只能在进程使用完毕后释放。
4. 循环等待条件：存在一种进程资源的循环等待链。

死锁产生的原因可以总结为以下几点：

1. 系统资源不足：进程竞争有限的资源而无法满足所有进程的需求。
2. 进程推进顺序非法：进程在等待资源时，无法正确释放已经占有的资源。
3. 资源分配不当：进程对资源的请求顺序不合理，导致多个进程互相等待。

预防死锁的方法包括：

1. 预防互斥条件：可以通过改变资源类型或范围，使资源可共享。
2. 预防请求与保持条件：在每次申请资源时，要求进程先释放已经占有的资源。
3. 预防资源不可剥夺条件：允许抢占进程已经占有的资源。
4. 预防循环等待条件：通过破坏环路等待条件来预防死锁，如实施资源有序分配策略或引入资源的层级关系。

此外，还可以使用以下方法来应对或解决死锁问题：

1. 死锁检测与恢复：周期性地对进程和资源进行检测，发现死锁后通过抢占资源或终止进程来解除死锁。
2. 死锁避免：根据系统状态和进程的请求情况预测是否会发生死锁，采取合适的措施来避免发生死锁。
3. 死锁忽略：对于某些应用领域而言，死锁发生的概率极低，可以忽略不予处理。

综上所述，死锁是在并发系统中多个进程相互等待资源导致系统无法继续执行的状态。预防死锁需要破坏死锁产生的必要条件，并采取相应的措施避免或解决死锁问题。



## 说一说 select 的原理以及缺点

select 是一种 IO 多路复用技术，其主要原理是通过构造一个文件描述符的列表并调用 select() 系统调用来监听这些文件描述符的事件。下面是具体的原理过程：

1. 构造文件描述符列表：在调用 select() 之前，需要构造一个 fd_set 类型的数组，该数组可容纳一定数量的文件描述符（默认为 1024），每个文件描述符对应一个比特位。设置这些比特位的值来表示是否需要监听该文件描述符的事件。

2. 调用 select() 系统调用：将构造好的文件描述符列表作为参数传递给 select() 函数。该函数会使调用进程进入阻塞状态，直到所监听的文件描述符中有一个或多个发生了 I/O 事件，或者设置的超时时间到达。

3. 内核态检测：select() 函数通过将文件描述符列表从用户态拷贝到内核态，由内核完成对这些文件描述符的事件检测。当有文件描述符的事件发生时，内核会修改对应文件描述符的比特位的值。

4. select() 返回：当有文件描述符的事件发生或者超时时间到达时，select() 函数会返回，告知调用进程有多少个描述符发生了事件。返回值为发生事件的文件描述符的数量。

5. 遍历并处理事件：根据 select() 返回的结果，调用进程需要遍历文件描述符列表，进一步判断哪些文件描述符发生了事件，并进行相应的 I/O 操作。

select 的缺点包括：

1. 每次调用 select() 都需要将文件描述符列表从用户态拷贝到内核态，这对于文件描述符较多时会产生较大的开销。
2. 每次调用 select() 都需要在内核中遍历传递进来的所有文件描述符，对于文件描述符较多时也会产生较大的开销。
3. select() 默认支持的文件描述符数量较小，默认为 1024，这限制了其适用范围。
4. 文件描述符集合在每次 select() 返回后需要重置，因为内核会修改对应的比特位值。
5. 每次 select() 返回后，只能得知有多少个文件描述符发生了事件，还需要遍历文件描述符集合才能确定具体是哪些文件描述符发生了事件。

综上所述，select 利用文件描述符列表和 select() 系统调用来监听文件描述符的事件，并通过遍历文件描述符集合进一步处理事件。其缺点包括拷贝开销、遍历开销、支持数量限制以及需要进一步判断具体发生事件的文件描述符。





## C++ 11 新特性

1. 稳定性和兼容性
原始字面量
超长整形 long long
类成员的快速初始化
final 和 override
模板的优化
数值类型和字符串之间的转换
静态断言 static_assert
noexcept
2. 易学和易用性
自动类型推导
基于范围的for循环
指针空值类型 - nullptr
lambda表达式
3. 通用性能的提升
常量表达式修饰符 - constexpr
委托构造函数和继承构造函数
右值引用
转移和完美转发
列表初始化
using的使用
可调用对象包装器、绑定器
POD类型
默认函数控制 =default 与 =delete
扩展的friend语法
强类型枚举
非受限联合体
4. 安全性
共享智能指针

​		独占智能指针

​		弱引用智能指针

5. 多线程
处理日期和时间的chrono库

​		C++线程类 thread

​		线程命名空间 this_thread

​		call_once函数

​		线程同步之互斥锁 mutex

​		线程同步之条件变量

​		线程同步之原子变量 atomic

​		线程异步



## 如果父类没有virtual，而子类再写一个相同的函数，会怎么样

如果父类没有使用`virtual`关键字声明一个函数，子类再写一个与父类相同名称的函数不会有多态性的效果。当通过基类指针或引用调用该函数时，会始终调用基类中的函数，而不会调用子类中的函数。

例子：
```cpp
#include <iostream>

class Base {
public:
    void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base *ptr = new Derived();
    ptr->print();  // 输出: Base class

    delete ptr;
    return 0;
}
```

在上述代码中，`Base`类中的`print`函数没有使用`virtual`关键字声明为虚函数，而`Derived`类中重写了`print`函数。在`main`函数中，通过`Base`类指针指向一个`Derived`类对象，然后调用`print`函数。由于`print`函数不是虚函数，调用的是基类中的实现，输出为"Base class"而不是"Derived class"。



## C++ 的多态性通过哪些东西来实现的

C++中的多态性主要通过以下几个机制来实现：

1. 虚函数（Virtual Functions）: 声明基类的成员函数为虚函数，通过在基类中使用`virtual`关键字来实现。当通过基类指针或引用调用虚函数时，根据实际对象的类型决定调用的是基类的实现还是派生类的实现。

2. 动态绑定（Dynamic Binding）: 通过虚函数表（vtable）来实现动态绑定。每个包含虚函数的类都会生成一个虚函数表，存放着虚函数的地址。当使用基类指针或引用调用虚函数时，会根据指针或引用所指向的实际对象的虚函数表来决定调用的具体函数。

3. 基类指针和引用：通过使用基类的指针或引用指向派生类对象，可以实现多态性。在运行时，根据指针或引用所指向的对象类型，来决定调用相应的函数。

4. 纯虚函数和抽象类（Abstract Class）：纯虚函数是基类中没有具体实现的虚函数，通过在函数声明中使用`= 0`来指定。抽象类包含纯虚函数，不能被直接实例化，只能被用作其他类的基类。通过继承抽象类，并在派生类中实现纯虚函数，可以实现对多态性的利用。

这些机制使得C++中的多态性成为可能，通过将函数的调用与实际对象的类型绑定起来，可以在运行时根据实际对象的类型来决定调用的函数，实现了多态性的特性。





## tcp,udp,ip头部有什么

tcp：1. 源端口和目标端口，2. 序列号，3. 确认号，4. 数据偏移，5. 控制位，6. 窗口大小，7. 校验和

upd：1. 源端口和目标端口，2. 长度， 3.校验码

ip：1. 版本，2. 首部长度，3. 服务类型，4. 总长度，5. 标识，6. 标志，7. 片偏移，8. 生存时间，9. 协议，10. 头部校验和，11. 源ip，12. 目的ip



## tcp，ip 有几个字节

tcp头通常是20字节，可以扩展到60字节

ip头通常是20字节，ipv4可以扩展到60字节，ipv6头是40字节



## 如何修改socket接收缓冲区大小

在 /proc/sys/net/core/ 下

rmem_max：一个Socket的读缓冲区可由程序设置的最大值，单位字节；

wmem_max：一个Socket的写缓冲区可由程序设置的最大值，单位字节；

rmem_default：一个Socket的被创建出来时，默认的读缓冲区大小，单位字节；

wmem_default：一个Socket的被创建出来时，默认的写缓冲区大小，单位字节；



## 调用malloc，操作系统的过程

当程序调用 `malloc` 函数请求内存时，该函数首先检查内存池中是否有足够的空闲内存块可以满足请求。如果有，`malloc` 直接返回这些内存块；如果没有，`malloc` 会通过 `brk()` 或 `mmap()` 系统调用增加程序的堆大小，以满足需求。

-   方式一：通过 brk() 系统调用从堆分配内存
-   方式二：通过 mmap() 系统调用在文件映射区域分配内存；

-   如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
-   如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；



4.项目里的mmap怎么实现的
5.如果多进程同时读写一个文件，怎么保证可见性
6.项目的用户态多线程怎么实现的
7.用户态和内核态
8.gdb怎么用的
9.静态变量在哪儿初始化的
10.说一下编译的过程，那静态变量是在哪个阶段初始化的?
11.要想调试需要怎么编译?





## 怎么样会造成内存泄漏？ 



c++ new 了一个对象，但是不delete



以下是一些实际的内存泄漏例子：

1. **文件操作**：在C++中，如果你打开了一个文件，但是在操作完成后没有关闭它，这可能会导致内存泄漏。例如：

```cpp
#include <fstream>

void readFile() {
    std::ifstream file("example.txt");
    // ... 进行文件操作
    // 忘记关闭文件
}
```

为了避免这种情况，你应该在操作完成后关闭文件：

```cpp
#include <fstream>

void readFile() {
    std::ifstream file("example.txt");
    // ... 进行文件操作
    file.close(); // 关闭文件
}
```

2. **动态数组**：在C++中，如果你使用`new`创建了一个动态数组，但是没有使用`delete[]`释放内存，这会导致内存泄漏。例如：

```cpp
int* createArray(int size) {
    int* arr = new int[size];
    // ... 初始化数组
    return arr;
}

void useArray() {
    int* myArray = createArray(10);
    // ... 使用数组
    // 忘记释放内存
}
```

为了避免这种情况，你应该在不再需要数组时使用`delete[]`释放内存：

```cpp
void useArray() {
    int* myArray = createArray(10);
    // ... 使用数组
    delete[] myArray; // 释放内存
}
```

3. **循环引用**：在使用智能指针（如`std::shared_ptr`）时，如果出现循环引用，也可能导致内存泄漏。例如：

```cpp
#include <memory>

class Node {
public:
    std::shared_ptr<Node> next;
};

void createCycle() {
    std::shared_ptr<Node> node1 = std::make_shared<Node>();
    std::shared_ptr<Node> node2 = std::make_shared<Node>();
    node1->next = node2;
    node2->next = node1; // 创建循环引用
}
```

为了避免这种情况，你可以使用`std::weak_ptr`来解决循环引用问题：

```cpp
#include <memory>

class Node {
public:
    std::weak_ptr<Node> next;
};

void createCycle() {
    std::shared_ptr<Node> node1 = std::make_shared<Node>();
    std::shared_ptr<Node> node2 = std::make_shared<Node>();
    node1->next = node2;
    node2->next = node1; // 使用weak_ptr避免循环引用
}
```

这些例子展示了一些常见的内存泄漏场景。要避免内存泄漏，需要在编程时关注内存管理，并确保在适当的时候释放内存。







## 0927 美团





MySQL   

隔离级别

怎么解决幻读

索引的类型

身份证表，用哪个字段建立索引比较合适，可以用性别吗

怎么排查慢SQL

消息队列用过吗，怎么保证不重复消费

Redis

基本类型

缓存穿透，击穿，雪崩

设计模式了解过哪些

计算机网络

TCP三次握手，四次挥手

HTTP和HTTPS的区别



多线程编程

	网络编程

socket编程



redis

\1. 项目，考虑100w访问量该怎么做
\2. 多态怎么实现
\3. 函数调用的过程
\4. 指针多大，为什么是8个字节
\5. static关键字
\6. 线程和进程的区别
\7. 虚拟地址与物理地址
手撕：手写LRU



## 内存泄漏的几种情况是？

内存泄漏可以出现在不同的情况下，以下是一些常见的内存泄漏情况：

1.  动态分配内存后未释放：当使用malloc、new等函数动态分配内存时，如果在使用完后没有及时调用free或delete释放内存，就会发生内存泄漏。
2.  对象生命周期过长：当一个对象的生命周期超过了它的实际使用需要时，该对象占用的内存就会一直得不到释放，造成内存泄漏。这可能发生在全局变量或者单例模式中，对象被一直保持在内存中而没有被释放。
3.  循环引用：当存在互相引用的对象，而这些对象之间没有断开引用关系时，就会导致循环引用，从而导致对象无法被垃圾回收，造成内存泄漏。
4.  长时间运行的任务：在程序运行过程中，如果有长时间运行的任务（如后台线程、定时任务等），而这些任务在运行过程中分配了大量内存，但在任务结束后没有释放内存，就会造成内存泄漏。
5.  未关闭资源：在使用一些需要手动关闭的资源时，比如文件、数据库连接等，如果没有在使用完后及时关闭或释放这些资源，就会导致资源占用不释放，进而造成内存泄漏。

解决这些情况的方法主要包括及时释放内存、管理对象生命周期、断开循环引用、合理使用资源以及定期检查和测试代码等。



## 如何调试内存泄漏问题？c++

在C++中，调试内存泄漏问题可以通过以下几个步骤进行：

1.  **识别内存泄漏的迹象**：内存泄漏通常表现为程序运行时间越长，占用的内存越多。如果你的程序表现出这种迹象，那么很可能存在内存泄漏问题。
2.  **使用工具检测内存泄漏**：有许多工具可以帮助你检测内存泄漏，例如Valgrind、AddressSanitizer和Visual Studio的内存诊断工具。这些工具可以帮助你定位内存泄漏的位置。
3.  **审查代码**：在定位到内存泄漏的位置后，仔细审查相关代码。检查是否有未正确释放的动态分配内存，例如使用`new`分配的内存没有使用`delete`释放，或者使用`malloc`分配的内存没有使用`free`释放。
4.  **使用智能指针**：C++11引入了智能指针，如`std::shared_ptr`和`std::unique_ptr`，它们可以自动管理内存。使用智能指针可以减少内存泄漏的风险。
5.  **避免循环引用**：确保你的代码中没有循环引用，特别是在使用`std::shared_ptr`时。循环引用可能导致内存泄漏，因为智能指针无法正确释放内存。在这种情况下，可以考虑使用`std::weak_ptr`来打破循环引用。
6.  **编写测试用例**：编写针对可能出现内存泄漏的代码的测试用例，并使用内存泄漏检测工具进行测试。这有助于确保在修改代码后，内存泄漏问题得到解决。
7.  **优化内存管理**：在某些情况下，内存泄漏可能是由于内存管理不当导致的。考虑使用内存池、对象池或其他内存管理策略来优化内存使用。

通过以上步骤，你可以有效地调试和解决C++程序中的内存泄漏问题。在编写代码时，始终关注内存管理和资源释放，以降低内存泄漏的风险。



## gdb在项目当中怎么用的

`gdb` 是一款强大的UNIX系统下的开源图形界面调试器，主要用于C、C++等程序的调试。下面是 gdb 在项目中的一些基本用法：

1. 启动 gdb：你可以通过在命令行中输入 `gdb` 后接程序的名字来启动 gdb，如 `gdb <your_program>`。

2. 设置断点：在 gdb 中，可以使用 `break` 命令配合行号或函数名来设置断点。例如 `break main` 会在 main 函数开始处设置断点，`break file.c:23` 会在 file.c 文件的第23行设置断点。

3. 运行程序：使用 `run` 或 `r` 命令来运行程序。如果你的程序需要命令行参数，可以将它们放在 `run` 后面，如 `run arg1 arg2`。

4. 单步执行：在 gdb 中，你可以使用 `step` 或 `s` 命令来单步执行程序，这会进入函数内部；或者使用 `next` 或 `n` 命令，这在遇到函数调用时会一次性执行完整个函数。

5. 查看变量值：你可以使用 `print` 或 `p` 命令来查看变量的值，如 `print variable_name`。

6. 继续执行：使用 `continue` 或 `c` 命令可以使程序继续执行，直到遇到下一个断点或程序结束。

7. 退出 gdb：你可以使用 `quit` 或 `q` 命令来退出 gdb。

注意，要使用 gdb 调试，你需要在编译程序时开启调试信息，通常是在 gcc 或 g++ 的命令行参数中加入 `-g`。

以上只是 gdb 的一些基本用法，gdb 的功能非常丰富，可以进行各种复杂的调试任务。你可以查看 gdb 的手册或在线资源来了解更多信息。



## sizeof一个类，类有5个函数，其中2个虚函数，还有一个整型，一个short

在C++中，`sizeof`操作符用于计算一个类型或对象所占用的字节大小。对于一个类，`sizeof`计算的是类的实例所占用的内存大小。类的成员函数（包括虚函数）不会影响类实例的大小，因为成员函数在内存中只有一份，被所有实例共享。所以，我们只需要考虑类的数据成员。

假设有一个类如下：

```cpp
class MyClass {
public:
    int a;
    short b;

    void func1() {}
    void func2() {}
    virtual void func3() {}
    virtual void func4() {}
    void func5() {}
};
```

这个类有一个整型（`int`）和一个短整型（`short`）数据成员。在大多数情况下，`int`占用4个字节，`short`占用2个字节。但是，这个类还有两个虚函数，这意味着类需要一个虚函数表指针（vptr）来访问虚函数表。通常，指针的大小与平台有关，32位平台上为4个字节，64位平台上为8个字节。

因此，`sizeof(MyClass)`的结果将取决于平台：

- 32位平台：4（int）+ 2（short）+ 4（vptr）= 10字节。但是，由于内存对齐，实际大小可能会增加到12字节。
- 64位平台：4（int）+ 2（short）+ 8（vptr）= 14字节。同样，由于内存对齐，实际大小可能会增加到16字节。

请注意，这些结果可能因编译器和平台的不同而有所不同。要获得确切的结果，可以在特定平台和编译器上使用`sizeof`操作符。





## 查找某个字符串在哪个文件当中用什么命令

在Linux和Unix系统中，可以使用`grep`命令来查找包含特定字符串的文件。`grep`是一个强大的文本搜索工具，它可以在文件中搜索匹配的字符串或正则表达式。

要查找包含特定字符串的文件，请使用以下命令格式：

```
grep -r "要查找的字符串" /path/to/directory
```

其中，`-r`选项表示递归搜索，`"要查找的字符串"`是您要在文件中查找的字符串，`/path/to/directory`是要搜索的目录路径。

例如，如果您要在`/home/user/documents`目录中查找包含字符串`example`的文件，可以使用以下命令：

```
grep -r "example" /home/user/documents
```

这将返回包含`example`字符串的所有文件及其所在行。



##  bss和data区别，static放在哪，static未初始化放在哪；

在C语言中，程序在内存中的布局被分为几个不同的区段或段：

1. BSS区：这个段存储程序中未初始化的全局变量和静态变量。

2. 数据区：这个段用于存储程序中已初始化的全局变量和静态变量。

在您的问题中，关于static关键字的用法：

- 静态全局变量或静态函数（函数前面有static修饰符）的作用域仅限于定义它们的文件内。它们在内存中的存储位置取决于它们是否被初始化。
- 如果静态变量被初始化了，它们将被存储在数据区。
- 如果静态变量未被初始化，它们将被存储在BSS区。





\8. 关系型数据库特点，redis过期管理，定时器原理；
\9. tcp和udp区别，tcp如何解析json，udp会考虑这个问题吗；

二面 40分钟
项目
索引创建、缓存设计、数据压缩、中间件（grpc、brpc看过吗、web开发）
链表解环、数组唯一的数


作者：祈愿offer多多的Alex
链接：[https://www.nowcoder.com/interview/center?entranceType=%E5%AF%BC%E8%88%AA%E6%A0%8F](https://www.nowcoder.com/interview/center?entranceType=导航栏)
来源：牛客网
