# 面试
## 1.内联函数，优点及缺点

内联函数是一种在编译时将函数体直接插入到每个调用位置的函数。这样可以减少函数调用的开销，因为不需要跳转到函数，保存寄存器，然后再跳回来。但是，如果函数体很大，这可能会导致代码膨胀，因为函数体的每个副本都需要空间。

优点：

1.  内联函数可以提高程序的运行速度，因为它们消除了函数调用的开销。
2.  内联函数在编译时展开，因此编译器有更多的优化机会，例如常量折叠。

缺点：

1.  内联函数可能会导致代码膨胀。如果函数体很大，或者内联函数在代码中被频繁调用，那么编译后的代码可能会变得非常大。

2.  内联函数可能会导致编译时间增加，因为编译器需要处理更多的代码。

3.  如果修改了内联函数的定义，那么所有使用该函数的代码都需要重新编译。

    

## 3.容器：map，set

在C++中，`map`和`set`都是基于红黑树（一种自平衡二叉查找树）实现的

`unordered_map`和`unordered_set`的内部实现是哈希表，因此它们的查找、插入和删除操作的平均时间复杂度是O(1)。然而，由于哈希表的特性，它们不保证元素的顺序。

在拉链法中，每个哈希表的元素都是一个链表。当新的数据项映射到已经有数据项的地址时，新的数据项就被添加到该地址的链表中。



## 4. 浏览器输入网址，直到打开网页的过程

浏览器输入网址到打开网页的过程包括以下步骤：

1.  **DNS 解析**：浏览器首先会进行 DNS 解析，将你输入的网址（例如 [www.example.com](http://www.example.com/)）转换为服务器的 IP 地址。
2.  **建立 TCP 连接**：浏览器与服务器建立 TCP 连接，这通常涉及到一个“三次握手”的过程。
3.  **发送 HTTP 请求**：浏览器向服务器发送 HTTP 请求，请求包括你想要获取的资源（例如一个网页）。
4.  **服务器处理请求并返回 HTTP 响应**：服务器处理你的请求，然后返回一个 HTTP 响应，响应中包含你请求的资源，例如一个 HTML 文件。
5.  **浏览器渲染页面**：浏览器接收到服务器返回的 HTML 文件后，开始解析 HTML，CSS 和 JavaScript，然后渲染出页面。
6.  **关闭 TCP 连接**：如果 HTTP 响应头中的 `Connection` 字段的值为 `close`，或者 HTTP 1.0 协议默认不支持长连接，那么浏览器和服务器的 TCP 连接会在数据交换完毕后关闭。



## 8.tcp头有哪些字段

TCP（Transmission Control Protocol，传输控制协议）头部包含以下字段：

1.  **源端口**（Source Port）：16位，用于标识发送端的应用程序。
2.  **目标端口**（Destination Port）：16位，用于标识接收端的应用程序。
3.  **序列号**（Sequence Number）：32位，用于标识从TCP源端向目标端发送的字节流，它表示在这个报文段中的的第一个数据字节。
4.  **确认号**（Acknowledgement Number）：32位，只有ACK标志位为1时，确认号字段才有效。ACK=1，确认号值为期望收到对方下一个报文段的第一个数据字节的序列号。
5.  **数据偏移**（Data Offset）：4位，指示TCP报文段的数据起始处距TCP报文段的起始处有多远。
6.  **保留**（Reserved）：6位，为后续使用而保留，目前值为0。
7.  **控制位**（Control Bits）：包括URG、ACK、PSH、RST、SYN、FIN等6个标志位。
8.  **窗口大小**（Window Size）：16位，用于流量控制。
9.  **校验和**（Checksum）：16位，用于错误检测。
10.  **紧急指针**（Urgent Pointer）：16位，只有URG标志位为1时，紧急指针字段才有效。
11.  **选项**（Options）：长度可变，最多可有40字节。不是所有的TCP报文段都有该字段。





## 公网ip怎么映射成私网ip

通过NAT转换



## 网络号怎么计算

网络号(Network ID)是一个用于识别特定网络的唯一标识符。在IP地址中，网络号是IP地址的一部分，它标识了网络的位置。网络号和主机号一起构成了一个完整的IP地址。

IP地址 192.168.1.1和 一个子网掩码255.255.255.0，它们取AND，因此网络号是192.168.1.0



## 进程间通信

进程间通信（Inter-Process Communication，IPC）是指在不同进程之间传递数据或信号的一种机制。在操作系统中，有多种方法可以实现进程间通信，包括管道（Pipe）、消息队列（Message Queuing）、信号（Signal）、共享内存（Shared Memory）、套接字（Socket）等。

以下是一些基本的IPC方法：

1.  **管道（Pipe）**：管道是一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

```
#include <unistd.h>
int pipe(int pipefd[2]);
```

1.  **消息队列（Message Queuing）**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冡区大小受限等缺点。

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
msgget(key_t key, int msgflg);
```

1.  **信号（Signal）**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

```
#include <signal.h>
void (*signal(int signum, void (*handler)(int)))(int);
```

1.  **共享内存（Shared Memory）**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

```
#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

1.  **套接字（Socket）**：套接字是一种全双工的通信方式，可用于不同机器之间的进程通信。

```
#include <sys/types.h>
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

以上就是进程间通信的基本方法，每种方法都有其适用的场景和优缺点，需要根据实际需求来选择。







## 简述一下 GDB 常见的调试命令

GDB（GNU调试器）是一个强大的Unix下的源代码级调试器。下面是一些常见的GDB命令：

- `run` (`r`): 开始程序的执行。如果程序需要命令行参数，你可以在`run`后面添加这些参数。

- `break` (`b`): 设置断点。你可以使用函数名、源文件名和行号等来设置断点。如 `break main` 或 `break myfile.c:20`。

- `continue` (`c`): 继续运行程序，直到下一个断点或者程序结束。

- `next` (`n`): 执行下一行代码。如果当前行有函数调用，`next`会跳过整个函数。

- `step` (`s`): 执行下一行代码。如果当前行有函数调用，`step`会进入函数。

- `print` (`p`): 打印表达式的值。例如，`print foo`会打印变量`foo`的值。

- `list` (`l`): 显示源代码。你可以使用`list`命令无参数地查看当前执行的代码周围的源代码，或者指定一个函数名或者行号来查看特定的源代码。

- `quit` (`q`): 退出GDB。

- `backtrace` (`bt`): 显示函数调用栈。这在你需要知道函数调用的顺序或者当前在哪个函数中时非常有用。

- `info` (`i`): 显示各种信息。例如，`info locals`会显示当前栈帧的局部变量，`info breakpoints`会显示所有的断点。

- `set var`: 修改变量的值。例如，`set var foo=5`会设置变量`foo`的值为5。

- `watch`: 设置一个观察点，当指定的表达式的值改变时，程序会暂停执行。

每个命令都有更详细的选项和用法，你可以在GDB中使用`help`命令来查看更多的信息。





## 静态库和动态库如何制作及使用，区别是什么

静态库和动态库是两种不同的软件库类型，它们都用来存储编译后的代码，但其使用方式和制作步骤存在一些差异。

#### 制作静态库

假设你有一些`.c`源文件，你可以通过以下步骤创建静态库：

1. 编译源文件为目标文件。例如，对于源文件`a.c`和`b.c`，你可以在命令行中使用以下命令：

    ```
    gcc -c a.c b.c
    ```

    这会生成`a.o`和`b.o`目标文件。

2. 使用`ar`命令创建静态库。例如，创建一个名为`libfoo.a`的库，可以使用以下命令：

    ```
    ar rcs libfoo.a a.o b.o
    ```

#### 制作动态库

制作动态库的步骤与制作静态库类似，但是需要使用不同的标志。例如，对于同样的`a.c`和`b.c`源文件，你可以使用以下命令：

1. 编译源文件为目标文件，但要使用`-fPIC`标志，这是为了生成位置无关代码：

    ```
    gcc -c -fPIC a.c b.c
    ```

2. 使用`-shared`标志创建动态库。例如，创建一个名为`libfoo.so`的库，可以使用以下命令：

    ```
    gcc -shared -o libfoo.so a.o b.o
    ```

#### 使用静态库和动态库

在你的程序中使用这些库，你需要在链接时指定它们。例如，如果你的程序源文件是`main.c`，你可以使用以下命令链接静态库：

```
gcc main.c -L. -lfoo -o main
```

同样，你可以使用以下命令链接动态库：

```
gcc main.c -L. -lfoo -o main
```

在这里，`-L.`告诉链接器在当前目录中搜索库，`-lfoo`告诉链接器链接名为`libfoo`的库（无论是`.a`还是`.so`）。

#### 静态库和动态库的区别

静态库在编译时被包含在最终的可执行文件中，这意味着如果程序使用了静态库，那么这个库的所有代码都会被复制到最终的可执行文件中。这会使得可执行文件变大，但在运行程序时不需要额外的依赖。

相比之下，动态库在运行时被加载。这意味着可执行文件只包含一些引用到动态库的代码的标识，而不是库的实际代码。这可以使得可执行文件更小，但在运行时需要确保动态库可用。

此外，动态库还有一些其他的优点，例如可以被多个程序共享，可以被热更新等。但是，动态库也带来了一些复杂性，例如需要正确配置库的搜索路径，处理版本兼容性等。





## 说一说进程调度算法有哪些

进程调度算法是操作系统用于决定哪个进程应该获得处理器资源的方法。以下是一些常见的进程调度算法：

- **先来先服务 (First-Come, First-Served, FCFS)**: 这是最简单的调度算法。在这种模式下，操作系统按照进程到达的顺序进行调度。FCFS算法可能导致"饥饿"，也就是某些进程可能需要等待很长时间才能得到执行。

- **最短作业优先 (Shortest Job Next, SJN)**: SJN算法选择最短执行时间的进程进行调度。这种算法可以最小化平均等待时间，但是也可能导致长作业饥饿。

- **优先级调度 (Priority Scheduling)**: 在这种算法下，每个进程都有一个优先级，优先级高的进程被优先调度。优先级调度可能会引起低优先级进程饥饿，这可以通过引入优先级老化（即，等待时间越长的进程，其优先级逐渐提高）来解决。

- **轮转法 (Round Robin, RR)**: RR算法中，每个进程都被分配到一小段连续的执行时间，称为时间片。当一个进程的时间片用完，就把CPU分配给下一个进程。这种方法避免了饥饿问题，但是如果时间片选择不当，可能会导致过多的上下文切换，降低系统性能。

- **多级反馈队列 (Multi-Level Feedback Queue, MLFQ)**: MLFQ结合了优先级调度和RR的特点。它将进程分成多个队列，每个队列有不同的优先级。在同一队列中，进程通过RR进行调度。当一个进程用完其分配的时间片，它会被移动到优先级更低的队列。这个算法试图给予短作业和I/O密集型进程更多的处理器时间。

以上都是理想化的调度算法，实际的操作系统会使用更复杂的调度策略，可能会结合上述多种算法的特点。





## 说一说什么是大端、小端，如何判断大端和小端

**大端 (Big Endian)** 和 **小端 (Little Endian)** 是计算机科学中的术语，用于描述字节序或者端序，即数据在内存中如何存储和读取。

- **大端 (Big Endian)**: 高位字节存储在内存的低地址中，低位字节存储在内存的高地址中。例如，一个32位的整数0x12345678，在大端模式下存储为：

    ```
    低地址 -> | 12 | 34 | 56 | 78 | <- 高地址
    ```

- **小端 (Little Endian)**: 低位字节存储在内存的低地址中，高位字节存储在内存的高地址中。同样的整数0x12345678，在小端模式下存储为：

    ```
    低地址 -> | 78 | 56 | 34 | 12 | <- 高地址
    ```

**判断大端和小端的方法**：

一种常见的判断系统是大端还是小端的方法是通过一个叫做"联合体 (union)"的数据结构。联合体可以让你在同一段内存上以多种方式进行读写。以下是一个使用C语言的示例：

```c
#include <stdio.h>

union {
    int i;
    char c[sizeof(int)];
} x;

int main() {
    x.i = 1;
    if (x.c[0] == 1) {
        printf("Little Endian\n");
    } else {
        printf("Big Endian\n");
    }
    return 0;
}
```

在这个代码中，我们创建了一个整数和一个字符数组共享存储空间的联合体。然后，我们给整数赋值为1，然后检查字符数组的第一个字节。如果第一个字节为1，那么系统为小端模式。如果不是，那么系统为大端模式。



## 请你说说进程和线程的区别

**进程（Process）** 和 **线程（Thread）** 都是操作系统的基本概念，它们是操作系统进行资源分配和调度的基本单位，但是它们之间有一些重要的区别。

- **进程：** 进程是操作系统进行资源分配的基本单位，它包含了运行程序所需要的资源，如CPU时间、内存空间、文件、设备等。每个进程都有自己的独立地址空间，一个进程无法直接访问另一个进程的资源。

- **线程：** 线程是操作系统进行调度的基本单位，它是在进程内部的一个独立执行路径。一个进程可以包含多个线程，这些线程共享进程的地址空间和其它资源，可以并发执行。

以下是进程和线程的主要区别：

1. **资源开销：** 创建或者终止一个进程的开销通常要大于创建或者终止一个线程。同样，由于进程间的切换需要交换更多的信息，所以进程切换的开销也比线程切换大。

2. **通信：** 由于同一进程下的线程共享内存和其它资源，所以线程间的通信比较容易。而进程间的通信（IPC，Inter-Process Communication）需要使用特定的操作系统API，相比较而言比较复杂。

3. **安全：** 由于进程有独立的地址空间，所以一个进程崩溃不会影响其他进程，这对于系统的稳定性和安全性是有利的。而多线程程序中，一个错误的线程可能影响整个进程的稳定性。

总的来说，进程和线程都是多任务处理的手段，它们各有优缺点。在编程时，应根据应用的需求和特性选择使用进程还是线程。





## 请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁

死锁是指在并发系统中，两个或多个进程互相等待对方所持有的资源，而导致所有进程处于无法继续执行的状态。

死锁产生的必要条件包括：

1. 互斥条件：资源只能被一个进程占有或使用。
2. 请求与保持条件：一个进程在请求资源的同时已经占有了至少一个资源。
3. 资源不可剥夺条件：资源只能在进程使用完毕后释放。
4. 循环等待条件：存在一种进程资源的循环等待链。

死锁产生的原因可以总结为以下几点：

1. 系统资源不足：进程竞争有限的资源而无法满足所有进程的需求。
2. 进程推进顺序非法：进程在等待资源时，无法正确释放已经占有的资源。
3. 资源分配不当：进程对资源的请求顺序不合理，导致多个进程互相等待。

预防死锁的方法包括：

1. 预防互斥条件：可以通过改变资源类型或范围，使资源可共享。
2. 预防请求与保持条件：在每次申请资源时，要求进程先释放已经占有的资源。
3. 预防资源不可剥夺条件：允许抢占进程已经占有的资源。
4. 预防循环等待条件：通过破坏环路等待条件来预防死锁，如实施资源有序分配策略或引入资源的层级关系。

此外，还可以使用以下方法来应对或解决死锁问题：

1. 死锁检测与恢复：周期性地对进程和资源进行检测，发现死锁后通过抢占资源或终止进程来解除死锁。
2. 死锁避免：根据系统状态和进程的请求情况预测是否会发生死锁，采取合适的措施来避免发生死锁。
3. 死锁忽略：对于某些应用领域而言，死锁发生的概率极低，可以忽略不予处理。

综上所述，死锁是在并发系统中多个进程相互等待资源导致系统无法继续执行的状态。预防死锁需要破坏死锁产生的必要条件，并采取相应的措施避免或解决死锁问题。



## 说一说 select 的原理以及缺点

select 是一种 IO 多路复用技术，其主要原理是通过构造一个文件描述符的列表并调用 select() 系统调用来监听这些文件描述符的事件。下面是具体的原理过程：

1. 构造文件描述符列表：在调用 select() 之前，需要构造一个 fd_set 类型的数组，该数组可容纳一定数量的文件描述符（默认为 1024），每个文件描述符对应一个比特位。设置这些比特位的值来表示是否需要监听该文件描述符的事件。

2. 调用 select() 系统调用：将构造好的文件描述符列表作为参数传递给 select() 函数。该函数会使调用进程进入阻塞状态，直到所监听的文件描述符中有一个或多个发生了 I/O 事件，或者设置的超时时间到达。

3. 内核态检测：select() 函数通过将文件描述符列表从用户态拷贝到内核态，由内核完成对这些文件描述符的事件检测。当有文件描述符的事件发生时，内核会修改对应文件描述符的比特位的值。

4. select() 返回：当有文件描述符的事件发生或者超时时间到达时，select() 函数会返回，告知调用进程有多少个描述符发生了事件。返回值为发生事件的文件描述符的数量。

5. 遍历并处理事件：根据 select() 返回的结果，调用进程需要遍历文件描述符列表，进一步判断哪些文件描述符发生了事件，并进行相应的 I/O 操作。

select 的缺点包括：

1. 每次调用 select() 都需要将文件描述符列表从用户态拷贝到内核态，这对于文件描述符较多时会产生较大的开销。
2. 每次调用 select() 都需要在内核中遍历传递进来的所有文件描述符，对于文件描述符较多时也会产生较大的开销。
3. select() 默认支持的文件描述符数量较小，默认为 1024，这限制了其适用范围。
4. 文件描述符集合在每次 select() 返回后需要重置，因为内核会修改对应的比特位值。
5. 每次 select() 返回后，只能得知有多少个文件描述符发生了事件，还需要遍历文件描述符集合才能确定具体是哪些文件描述符发生了事件。

综上所述，select 利用文件描述符列表和 select() 系统调用来监听文件描述符的事件，并通过遍历文件描述符集合进一步处理事件。其缺点包括拷贝开销、遍历开销、支持数量限制以及需要进一步判断具体发生事件的文件描述符。





## C++ 11 新特性

1. 稳定性和兼容性
原始字面量
超长整形 long long
类成员的快速初始化
final 和 override
模板的优化
数值类型和字符串之间的转换
静态断言 static_assert
noexcept
2. 易学和易用性
自动类型推导
基于范围的for循环
指针空值类型 - nullptr
lambda表达式
3. 通用性能的提升
常量表达式修饰符 - constexpr
委托构造函数和继承构造函数
右值引用
转移和完美转发
列表初始化
using的使用
可调用对象包装器、绑定器
POD类型
默认函数控制 =default 与 =delete
扩展的friend语法
强类型枚举
非受限联合体
4. 安全性
共享智能指针

​		独占智能指针

​		弱引用智能指针

5. 多线程
处理日期和时间的chrono库

​		C++线程类 thread

​		线程命名空间 this_thread

​		call_once函数

​		线程同步之互斥锁 mutex

​		线程同步之条件变量

​		线程同步之原子变量 atomic

​		线程异步



## 如果父类没有virtual，而子类再写一个相同的函数，会怎么样

如果父类没有使用`virtual`关键字声明一个函数，子类再写一个与父类相同名称的函数不会有多态性的效果。当通过基类指针或引用调用该函数时，会始终调用基类中的函数，而不会调用子类中的函数。

例子：
```cpp
#include <iostream>

class Base {
public:
    void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base *ptr = new Derived();
    ptr->print();  // 输出: Base class

    delete ptr;
    return 0;
}
```

在上述代码中，`Base`类中的`print`函数没有使用`virtual`关键字声明为虚函数，而`Derived`类中重写了`print`函数。在`main`函数中，通过`Base`类指针指向一个`Derived`类对象，然后调用`print`函数。由于`print`函数不是虚函数，调用的是基类中的实现，输出为"Base class"而不是"Derived class"。



## C++ 的多态性通过哪些东西来实现的

C++中的多态性主要通过以下几个机制来实现：

1. 虚函数（Virtual Functions）: 声明基类的成员函数为虚函数，通过在基类中使用`virtual`关键字来实现。当通过基类指针或引用调用虚函数时，根据实际对象的类型决定调用的是基类的实现还是派生类的实现。

2. 动态绑定（Dynamic Binding）: 通过虚函数表（vtable）来实现动态绑定。每个包含虚函数的类都会生成一个虚函数表，存放着虚函数的地址。当使用基类指针或引用调用虚函数时，会根据指针或引用所指向的实际对象的虚函数表来决定调用的具体函数。

3. 基类指针和引用：通过使用基类的指针或引用指向派生类对象，可以实现多态性。在运行时，根据指针或引用所指向的对象类型，来决定调用相应的函数。

4. 纯虚函数和抽象类（Abstract Class）：纯虚函数是基类中没有具体实现的虚函数，通过在函数声明中使用`= 0`来指定。抽象类包含纯虚函数，不能被直接实例化，只能被用作其他类的基类。通过继承抽象类，并在派生类中实现纯虚函数，可以实现对多态性的利用。

这些机制使得C++中的多态性成为可能，通过将函数的调用与实际对象的类型绑定起来，可以在运行时根据实际对象的类型来决定调用的函数，实现了多态性的特性。
