# 面试
## 1.内联函数，优点及缺点

内联函数是一种在编译时将函数体直接插入到每个调用位置的函数。这样可以减少函数调用的开销，因为不需要跳转到函数，保存寄存器，然后再跳回来。但是，如果函数体很大，这可能会导致代码膨胀，因为函数体的每个副本都需要空间。

优点：

1.  内联函数可以提高程序的运行速度，因为它们消除了函数调用的开销。
2.  内联函数在编译时展开，因此编译器有更多的优化机会，例如常量折叠。

缺点：

1.  内联函数可能会导致代码膨胀。如果函数体很大，或者内联函数在代码中被频繁调用，那么编译后的代码可能会变得非常大。

2.  内联函数可能会导致编译时间增加，因为编译器需要处理更多的代码。

3.  如果修改了内联函数的定义，那么所有使用该函数的代码都需要重新编译。

    

## 3.容器：map，set

在C++中，`map`和`set`都是基于红黑树（一种自平衡二叉查找树）实现的

`unordered_map`和`unordered_set`的内部实现是哈希表，因此它们的查找、插入和删除操作的平均时间复杂度是O(1)。然而，由于哈希表的特性，它们不保证元素的顺序。

在拉链法中，每个哈希表的元素都是一个链表。当新的数据项映射到已经有数据项的地址时，新的数据项就被添加到该地址的链表中。



## 4. 浏览器输入网址，直到打开网页的过程

浏览器输入网址到打开网页的过程包括以下步骤：

1.  **DNS 解析**：浏览器首先会进行 DNS 解析，将你输入的网址（例如 [www.example.com](http://www.example.com/)）转换为服务器的 IP 地址。
2.  **建立 TCP 连接**：浏览器与服务器建立 TCP 连接，这通常涉及到一个“三次握手”的过程。
3.  **发送 HTTP 请求**：浏览器向服务器发送 HTTP 请求，请求包括你想要获取的资源（例如一个网页）。
4.  **服务器处理请求并返回 HTTP 响应**：服务器处理你的请求，然后返回一个 HTTP 响应，响应中包含你请求的资源，例如一个 HTML 文件。
5.  **浏览器渲染页面**：浏览器接收到服务器返回的 HTML 文件后，开始解析 HTML，CSS 和 JavaScript，然后渲染出页面。
6.  **关闭 TCP 连接**：如果 HTTP 响应头中的 `Connection` 字段的值为 `close`，或者 HTTP 1.0 协议默认不支持长连接，那么浏览器和服务器的 TCP 连接会在数据交换完毕后关闭。



## 8.tcp头有哪些字段

TCP（Transmission Control Protocol，传输控制协议）头部包含以下字段：

1.  **源端口**（Source Port）：16位，用于标识发送端的应用程序。
2.  **目标端口**（Destination Port）：16位，用于标识接收端的应用程序。
3.  **序列号**（Sequence Number）：32位，用于标识从TCP源端向目标端发送的字节流，它表示在这个报文段中的的第一个数据字节。
4.  **确认号**（Acknowledgement Number）：32位，只有ACK标志位为1时，确认号字段才有效。ACK=1，确认号值为期望收到对方下一个报文段的第一个数据字节的序列号。
5.  **数据偏移**（Data Offset）：4位，指示TCP报文段的数据起始处距TCP报文段的起始处有多远。
6.  **保留**（Reserved）：6位，为后续使用而保留，目前值为0。
7.  **控制位**（Control Bits）：包括URG、ACK、PSH、RST、SYN、FIN等6个标志位。
8.  **窗口大小**（Window Size）：16位，用于流量控制。
9.  **校验和**（Checksum）：16位，用于错误检测。
10.  **紧急指针**（Urgent Pointer）：16位，只有URG标志位为1时，紧急指针字段才有效。
11.  **选项**（Options）：长度可变，最多可有40字节。不是所有的TCP报文段都有该字段。





## 公网ip怎么映射成私网ip

通过NAT转换



## 网络号怎么计算

网络号(Network ID)是一个用于识别特定网络的唯一标识符。在IP地址中，网络号是IP地址的一部分，它标识了网络的位置。网络号和主机号一起构成了一个完整的IP地址。

IP地址 192.168.1.1和 一个子网掩码255.255.255.0，它们取AND，因此网络号是192.168.1.0



## 进程间通信

进程间通信（Inter-Process Communication，IPC）是指在不同进程之间传递数据或信号的一种机制。在操作系统中，有多种方法可以实现进程间通信，包括管道（Pipe）、消息队列（Message Queuing）、信号（Signal）、共享内存（Shared Memory）、套接字（Socket）等。

以下是一些基本的IPC方法：

1.  **管道（Pipe）**：管道是一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

```
#include <unistd.h>
int pipe(int pipefd[2]);
```

1.  **消息队列（Message Queuing）**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冡区大小受限等缺点。

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
msgget(key_t key, int msgflg);
```

1.  **信号（Signal）**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

```
#include <signal.h>
void (*signal(int signum, void (*handler)(int)))(int);
```

1.  **共享内存（Shared Memory）**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

```
#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

1.  **套接字（Socket）**：套接字是一种全双工的通信方式，可用于不同机器之间的进程通信。

```
#include <sys/types.h>
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

以上就是进程间通信的基本方法，每种方法都有其适用的场景和优缺点，需要根据实际需求来选择。

